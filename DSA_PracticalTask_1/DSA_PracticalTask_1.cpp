#include <conio.h>
#include <stdio.h>
#include <locale.h>
#include <windows.h>

/// <summary>
/// Структура представляет собой модель члена полинома.
/// </summary>
struct term {
   /// <summary>
   /// Степень.
   /// </summary>
   UCHAR n;
   /// <summary>
   /// Коэффициент.
   /// </summary>
   float a;
   /// <summary>
   /// Указатель на следующий член полинома.
   /// </summary>
   term *next;
};


/// <summary>
/// Функция возвращает знак числа.
/// </summary>
/// <param name="n">Число, у которого нужно определить знак.</param>
/// <returns>'+' или '-'.</returns>
char sign(float n);

/// <summary>
/// Функция возвращает модуль числа.
/// </summary>
/// <param name="n">Число.</param>
/// <returns>Модуль числа.</returns>
float abs(float n);

/// <summary>
/// Выводит полином на консоль.
/// </summary>
/// <param name="p">Указатель на первый член полинома.</param>
/// <param name="c">Имя полинома.</param>
void printPolynomial(term *p, char c);

/// <summary>
/// Функция складывает 2 полинома друг с другом. 
/// </summary>
/// <param name="a">Указатель на первый полином.</param>
/// <param name="b">Указатель на второй полином.</param>
/// <returns>Указатель на полином, который будет результатом сложения первого и второго полиномов.</returns>
term * addPolynomials(term *a, term *b);

/// <summary>
/// Функция сортирует члены полинома в порядке убывания показателя степени его членов.
/// </summary>
/// <param name="p">Указатель на полином, который нужно сортировать.</param>
/// <param name="N">Степень полинома.</param>
void sortPolynomial(term *p, UCHAR N);

/// <summary>
/// Функция считывает из определенного файла 2 полинома.
/// </summary>
/// <param name="path">Путь к файлу.</param>
/// <param name="p">Указатель, в который нужно записать первый член одного полинома.</param>
/// <param name="q">Указатель, в который нужно записать первый член другого полинома.</param>
/// <returns>Степень прочитанных из файла полиномов.</returns>
UCHAR scanPolynomials(const char *path, term *p, term *q);


int main()
{
   setlocale(0, "");
   
   term *P = new term(), *Q = new term(), *R;
   
   UCHAR N = scanPolynomials("D:/polynomials6.txt", P, Q);
   sortPolynomial(P, N);
   sortPolynomial(Q, N);
   
   R = addPolynomials(P, Q);

   printPolynomial(P, 'P');
   printPolynomial(Q, 'Q');
   printPolynomial(R, 'R');

   return 0 * _getch();
}

UCHAR scanPolynomials(const char *path, term *p, term *q)
{
   UCHAR N = 0;

   FILE *stream;
   fopen_s(&stream, path, "r");

   if (stream)
   {
      // sign нужен для определения знака коэффициента, end - "флаг", обозначающий, что полином прочитан в файле до конца (данные тоже), если end = '\n'.
      char sign = '+', end = ' ';
      // r - указатель, с помощью которого осуществляется доступ к каждому члену полинома p. Читаем каждый член полиномов отдельно, пока не дойдем до конца файла (EOF). В конце каждой итерации проверяем, заполнен ли первый полином до конца. Если заполнен, то начинаем заполнять второй полином, иначе - переходим к следующему члену полинома, который заполняем сейчас.
      for (term *r = p; fscanf_s(stream, " %c %fx^%hhi%c", &sign, 1, &r->a, &r->n, &end, 1) != EOF; r = end == '\n' ? q : r->next, N++)
      {
         // Если знак перед членом отрицательный, то отрицаем коэффициент этого члена.
         if (sign == '-')
            r->a *= -1;
         // Если полином прочитан до конца, значит членов у него больше нет и значит, что указатель на следующий член у последнего прочитанного члена должен быть нулевым, иначе - создаем новый член и записываем его как следующий член.
         r->next = end == '\n' ? NULL : new term();
      }

      fclose(stream);
   }
   // Делим на 2, потому что у нас 2 полинома, - 1, потому что степень полинома = количество его членов - 1.
   return N / 2 - 1;
}

void sortPolynomial(term *p, UCHAR N)
{
   // Сортировка идет последовательно с первого члена полинома. Смотрим на степень члена и проверяем на своей ли позиции он стоит (степень члена = его позиция в полиноме). Если он не на своей позиции, то ищем его позицию, перебирая следующие члены, пока не дойдем до члена, стоящего на нужной позиции. Меняем их коэффициенты и показатели степени. В конце итерации на текущую позицию установлен соответствующий ей член. Сдвигаем искомую позицию на 1 и получаем член, который стоит на этой позиции и начинаем сортировку заново, пока не дойдем до 0-ой позиции.

   UCHAR pos = N; // Позиция, по которой ищется соответственный ей член.
   term *r = p, *t; // r - указывает на член, который стоит на pos, t - указывает на член, который стоит на позиции, на которой должен стоять r.

   // Эти переменные нужны для обмена данными между членами, на которые указывают r и t.
   float a = 0;
   UCHAR n = 0;

   for ( ; pos; pos--, r = r->next)
   {
      // Если член не на своем месте (степень члена и его позиция в полиноме должны совпадать), то 
      if (r->n != pos)
      {
         // Ищем член, который стоит на позиции члена, на который указывает r.
         for (t = r->next; t->n != pos; t = t->next);

         // Заменяем данные членов, на которые указывают r и t.
         a = r->a;
         n = r->n;

         r->a = t->a;
         r->n = t->n;

         t->a = a;
         t->n = n;
      }
   }
}

term * addPolynomials(term *a, term *b)
{
   // Указатель на первый элемент полинома суммы.
   term *r = new term();
   // На каждой итерации переходит к следующему элементу каждого полинома, пока не дойдет до последнего, у которого указатель на следующий равен NULL.
   for (term *p = r; a; p = p->next, a = a->next, b = b->next)
   {
      p->n = a->n;
      p->a = a->a + b->a;
      p->next = a->next ? new term() : NULL;
   }

   return r;
}

void printPolynomial(term *p, char c)
{
   bool f = false; // Индикатор "есть член перед текущим".
   printf_s("%cn(x) = ", c);
   for ( ; p; p = p->next)
   {
      if (p->n && p->a) // Если степень != 0 и коэф != 0, то
      {
         if (abs(p->a) != 1) // если |коэф| != 1, то
            // если есть предчлен, пишем " %с |%а|", иначе пишем "%а".
            f ? printf_s(" %c %g", sign(p->a), abs(p->a)) : printf_s("%g", p->a);
         // иначе, если есть предчлен пишем " %с ", иначе, "%с".
         else printf_s(f ? " %c " : "%c", sign(p->a));

         // если степень больше 1, то пишем "x^%n", иначе - "х".
         p->n > 1 ? printf_s("x^%d", p->n) : printf_s("x");
         f = true;
      }
      else if (!p->n) // иначе, если степень == 0, то
      {
         if (p->a && f) // если коэф != 0 и есть предчлен, то
            printf_s(" %c %g", sign(p->a), abs(p->a));
         else if(!f) printf_s("%g", p->a); // иначе, если нет предчлена, "%a".
         printf_s(".\n");
      }
   }
}
char sign(float n)
{
   return n > 0 ? '+' : '-';
}
float abs(float n)
{
   return sign(n) == '-' ? -1 * n : n;
}